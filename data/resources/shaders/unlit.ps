precision mediump float;

struct Light
{
	vec3	position;
	vec4	color;
	float	radius;
	int		type;
};
#define MAX_LIGHTS 3

uniform Light		lightList[MAX_LIGHTS];

uniform vec4		tintColor;
uniform vec3		inEyePos;
uniform sampler2D	albedoMap;
uniform sampler2D	roughnessMap;
uniform sampler2D	normalMap;


varying vec2		uv;
varying vec3		normal;
varying vec4		worldPos;
varying mat3		tbnMat;
varying vec3		tangent;
varying vec3		bitangent;
varying vec4		viewSpace;


float cookTorrenceSpecular( vec3 inNormal, vec3 inLightDir, vec3 inEyeDir, float inRoughness, float F0 )
{
	const float PI = 3.14159;

	vec3 eyeDir = inEyeDir;

	// calculate intermediary values
	float NdotL		= dot(inNormal, inLightDir);
	
	vec3 halfVector = normalize(inLightDir + eyeDir);
	float NdotH = max(dot(inNormal, halfVector), 0.0); 
	float NdotV = max(dot(inNormal, eyeDir), 0.0); // note: this could also be NdotL, which is the same value
	float VdotH = max(dot(eyeDir, halfVector), 0.0);
	float mSquared = inRoughness * inRoughness;
	
	// geometric attenuation
	float NH2 = 2.0 * NdotH;
	float g1 = (NH2 * NdotV) / VdotH;
	float g2 = (NH2 * NdotL) / VdotH;
	float geoAtt = min(1.0, min(g1, g2));
	
	// roughness (or: microfacet distribution function)
	// beckmann distribution function
	float r1 = 1.0 / ( 4.0 * mSquared * pow(NdotH, 4.0));
	float r2 = (NdotH * NdotH - 1.0) / (mSquared * NdotH * NdotH);
	float roughness = r1 * exp(r2);
	
	// fresnel
	// Schlick approximation
	float fresnel = pow(1.0 - VdotH, 5.0);
	fresnel *= (1.0 - F0);
	fresnel += F0;
	
	return (fresnel * geoAtt * roughness) / (NdotV * NdotL * PI);
}



float orenNayarLighting(vec3 inNormal, vec3 inLightDir, vec3 inEyeDir, float roughness )
{   
    const float PI = 3.14159;

    // interpolating normals will change the length of the normal, so renormalize the normal.
    vec3 normal = inNormal;
    vec3 eyeDir = inEyeDir;
    
    // calculate intermediary values
    float NdotL = dot(normal, inLightDir);
    float NdotV = dot(normal, eyeDir); 

    float angleVN = acos(NdotV);
    float angleLN = acos(NdotL);
    
    float alpha = max(angleVN, angleLN);
    float beta = min(angleVN, angleLN);
    float gamma = dot(eyeDir - normal * dot(eyeDir, normal), inLightDir - normal * dot(inLightDir, normal));
    
    float roughnessSquared = roughness * roughness;
    float roughnessSquared9 = (roughnessSquared / (roughnessSquared + 0.09));
    
    // calculate C1, C2 and C3
    float C1 = 1.0 - 0.5 * (roughnessSquared / (roughnessSquared + 0.33));
    float C2 = 0.45 * roughnessSquared9;
    
    if(gamma >= 0.0)
    {
        C2 *= sin(alpha);
    }
    else
    {
        C2 *= (sin(alpha) - pow((2.0 * beta) / PI, 3.0));
    }
 
    float powValue = (4.0 * alpha * beta) / (PI * PI);
    float C3  = 0.125 * roughnessSquared9 * powValue * powValue;
 
    // now calculate both main parts of the formula
    float A = gamma * C2 * tan(beta);
    float B = (1.0 - abs(gamma)) * C3 * tan((alpha + beta) / 2.0);
 
    // put it all together
    float L1 = max(0.0, NdotL) * (C1 + A + B);
    
    // also calculate interreflection
    float twoBetaPi = 2.0 * beta / PI;
	//TODO: p is squared in this case... how to separate this?
    float L2 = 0.17 * max(0.0, NdotL) * (roughnessSquared / (roughnessSquared + 0.13)) * (1.0 - gamma * twoBetaPi * twoBetaPi);
    
    return (L1 + L2);
}

float lambertLighting( vec3 lightDir, vec3 inNormal )
{
	vec3 normal = normalize(inNormal);
	return dot(normalize(lightDir), normal);
}


float getAttinuation( float radius, float distance )
{
	return clamp(1.0 - distance/radius, 0.0, 1.0); 
}

vec3 unpackNormal( mat3 inTBNMat, vec3 tangentNormal )
{
	vec3 outNormal = tangentNormal * 2.0 - 1.0;
	return normalize(inTBNMat * outNormal);
}

float fogAmount( in float distance, in float density )
{
	float fogFactor = 1.0 /exp( (distance * density)* (distance * density));
	return 1.0 - clamp( fogFactor, 0.0, 1.0 );
}

void main()
{ 

	const float uvScale = 12.0;

	vec4 albedoTex		= texture2D( albedoMap, uv * uvScale );
	vec4 roughnessTex	= texture2D( roughnessMap, uv * uvScale );
	vec4 normalTex		= texture2D( normalMap, uv * uvScale);
	
	const float F0 = 0.474;
	float k		= 1.0 - F0;

	float roughness		= 1.0 - roughnessTex.r;
	vec3 worldNormal	= normalize(normal);//unpackNormal( tbnMat, normalTex.xyz );
	
	vec3 eyeDir			= normalize(inEyePos - worldPos.xyz); 
	float fogDist		= distance(worldPos.xyz, inEyePos);

	vec4 ambient		= vec4(albedoTex.xyz * 0.01, 0);
	
	vec3 lightContrib	= vec3(0);
	for(int i = 0; i < MAX_LIGHTS; ++i)
	{
		bool directional = lightList[i].type == 0;
		vec3 lightDir	= -lightList[i].position;
		float attin		= 1.0;
		

		if(!directional)
		{
			lightDir	= lightList[i].position - worldPos.xyz;
			float dirMag	= length(lightDir);
			attin		= getAttinuation(lightList[i].radius, dirMag);
		}

		
		lightDir		= normalize(lightDir);
		
	//Diffuse reflection
		float diffuse	= dot(normal, lightDir) * (1.0 - F0);

	//Specular reflection
		float specular	= 0.0;
		if(diffuse > 0.0 )
		{
			specular	= k + cookTorrenceSpecular(worldNormal, lightDir, eyeDir, roughness, F0) * (1.0 - k);
		}

		lightContrib += lightList[i].color.rgb * lightList[i].color.a * diffuse * specular * attin;
	}
	
	float depth = length(viewSpace);
	float fog = fogAmount(depth, 0.011);

	vec4 finalColor = ambient + albedoTex * vec4(lightContrib, 1.0);
	gl_FragColor	= mix(clamp(finalColor, vec4(0), vec4(1)), vec4(0.43, 0.48, 0.67, 1), fog);
}
