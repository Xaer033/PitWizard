precision mediump float;

uniform vec4		tintColor;
uniform vec3		inEyePos;
uniform sampler2D	albedoMap;
uniform sampler2D	roughnessMap;
uniform sampler2D	normalMap;


varying vec2		uv;
varying vec3		normal;
varying vec4		worldPos;
varying mat3		tbnMat;
varying vec3		tangent;
varying vec3		bitangent;


float cookTorrenceSpecular( vec3 inNormal, vec3 inLightDir, vec3 inEyeDir, float inRoughness )
{
	const float PI = 3.14159;

	//Material Values
	const float F0 = 0.8; // fresnel reflectance at normal incidence

	vec3 eyeDir = normalize(inEyeDir);

	// calculate intermediary values
	float NdotL		= dot(inNormal, inLightDir);
	
	vec3 halfVector = normalize(inLightDir + eyeDir);
	float NdotH = max(dot(inNormal, halfVector), 0.0); 
	float NdotV = max(dot(inNormal, eyeDir), 0.0); // note: this could also be NdotL, which is the same value
	float VdotH = max(dot(eyeDir, halfVector), 0.0);
	float mSquared = inRoughness * inRoughness;
	
	// geometric attenuation
	float NH2 = 2.0 * NdotH;
	float g1 = (NH2 * NdotV) / VdotH;
	float g2 = (NH2 * NdotL) / VdotH;
	float geoAtt = min(1.0, min(g1, g2));
	
	// roughness (or: microfacet distribution function)
	// beckmann distribution function
	float r1 = 1.0 / ( 4.0 * mSquared * pow(NdotH, 4.0));
	float r2 = (NdotH * NdotH - 1.0) / (mSquared * NdotH * NdotH);
	float roughness = r1 * exp(r2);
	
	// fresnel
	// Schlick approximation
	float fresnel = pow(1.0 - VdotH, 5.0);
	fresnel *= (1.0 - F0);
	fresnel += F0;
	
	return (fresnel * geoAtt * roughness) / (NdotV * NdotL * PI);
}



float orenNayarLighting(vec3 inNormal, vec3 inLightDir, vec3 inEyeDir, float roughness )
{   
    const float PI = 3.14159;

    // interpolating normals will change the length of the normal, so renormalize the normal.
    vec3 normal = normalize(inNormal);
    vec3 eyeDir = normalize(inEyeDir);
    
    // calculate intermediary values
    float NdotL = dot(normal, inLightDir);
    float NdotV = dot(normal, eyeDir); 

    float angleVN = acos(NdotV);
    float angleLN = acos(NdotL);
    
    float alpha = max(angleVN, angleLN);
    float beta = min(angleVN, angleLN);
    float gamma = dot(eyeDir - normal * dot(eyeDir, normal), inLightDir - normal * dot(inLightDir, normal));
    
    float roughnessSquared = roughness * roughness;
    float roughnessSquared9 = (roughnessSquared / (roughnessSquared + 0.09));
    
    // calculate C1, C2 and C3
    float C1 = 1.0 - 0.5 * (roughnessSquared / (roughnessSquared + 0.33));
    float C2 = 0.45 * roughnessSquared9;
    
    if(gamma >= 0.0)
    {
        C2 *= sin(alpha);
    }
    else
    {
        C2 *= (sin(alpha) - pow((2.0 * beta) / PI, 3.0));
    }
 
    float powValue = (4.0 * alpha * beta) / (PI * PI);
    float C3  = 0.125 * roughnessSquared9 * powValue * powValue;
 
    // now calculate both main parts of the formula
    float A = gamma * C2 * tan(beta);
    float B = (1.0 - abs(gamma)) * C3 * tan((alpha + beta) / 2.0);
 
    // put it all together
    float L1 = max(0.0, NdotL) * (C1 + A + B);
    
    // also calculate interreflection
    float twoBetaPi = 2.0 * beta / PI;
	//TODO: p is squared in this case... how to separate this?
    float L2 = 0.17 * max(0.0, NdotL) * (roughnessSquared / (roughnessSquared + 0.13)) * (1.0 - gamma * twoBetaPi * twoBetaPi);
    
    return (L1 + L2);
}

float lambertLighting( vec3 lightDir, vec3 inNormal )
{
	vec3 normal = normalize(inNormal);
	return dot(normalize(lightDir), normal);
}


float getAttinuation( float radius, float distance )
{
	return clamp(1.0 - distance/radius, 0.0, 1.0); 
}

vec3 unpackNormal( mat3 inTBNMat, vec3 tangentNormal )
{
	vec3 outNormal = (tangentNormal * 2.0 - 1.0) * 0.5;
	return normalize(inTBNMat * outNormal);
}

void main()
{ 
	vec4 albedoTex		= texture2D( albedoMap, uv );
	vec4 roughnessTex	= texture2D( roughnessMap, uv );
	vec4 normalTex		= texture2D( normalMap, uv);

	vec3 worldNormal	= normal;//unpackNormal( tbnMat, normalTex.xyz );

	const vec4	lightPos		= vec4(0, 5, 0, 1);
	const vec4	lightColor		= vec4(1.0, 0.93, 0.83, 1.0);

	const float lightIntensity	= 3.0;
	const float lightRadius		= 20.0;
	const float k				= 0.5;
	float roughness				= 1.0 - roughnessTex.r;

	vec3 lightDir	= (lightPos - worldPos).xyz;
	float dirMag	= length(lightDir);
	lightDir		= normalize(lightDir);

	float attin		= getAttinuation(lightRadius, dirMag);

	vec3 eyeDir		= normalize(inEyePos - worldPos.xyz); 
//Diffuse reflection
	float diffuse	= orenNayarLighting(worldNormal, lightDir, eyeDir, roughness);

//Specular reflection
	float NdotL		= dot(normal, lightDir);
	float specular	= 1.0;
	if(NdotL > 0.0 )
	{
		specular	= k + cookTorrenceSpecular(worldNormal, lightDir, eyeDir, roughness) * (1.0 - k);
	}

	vec4 finalColor = albedoTex * lightColor * max(diffuse * specular * lightIntensity * attin, 0.02);
	gl_FragColor	= finalColor;
}
